%% Nix Quick Reference Sheet
%% James Geddes, The Alan Turing Institute, 2023
%% CC0
\documentclass[10pt, a4paper, landscape]{article}
\usepackage[T1]{fontenc}
\usepackage{multicol}
\setlength{\columnsep}{3em}
\usepackage[medium, compact]{titlesec}
\titleformat{\section}[block]{\Large\bfseries\filcenter}{\thesection}{1em}{}
\usepackage{beton}
\DeclareFontSeriesDefault[rm]{bf}{sbc}
\usepackage{eulervm}
\usepackage{amsmath}
\usepackage[margin=0.51in]{geometry}
\usepackage{parskip}
\usepackage{tabularx}
\usepackage{array}
\usepackage{booktabs}
\usepackage{microtype}
%\usepackage{fancyhdr}
%%
%%\usepackage[style=authoryear]{biblatex}
%%\addbibresource{notes.bib}
%%
%%
\newcommand{\cmd}[1]{\texttt{#1}}
\newcommand{\str}{\textsf{String}}
\newcommand{\pth}{\textsf{Path}}
\newcommand{\num}{\textsf{Number}}
\newcommand{\lst}{\textsf{List}}
\newcommand{\ats}{\textsf{Attrs}}
\newcommand{\bln}{\textsf{Bool}}

%%
\title{Nix Quick Reference}
%%\author{}
\date{\vskip-10ex November 2023}
%%
\renewcommand{\arraystretch}{1.2}
\setlength{\tabcolsep}{0.5em}
%%
\begin{document}%\maketitle
%%
\begin{multicols*}{3}\raggedcolumns%
%%
\maketitle

\section*{Builtins}

\subsection*{Operators}

The following are approximately in order of precendence. Function
application (represented by a space) has precedence just below
attribute selection.

The expression \emph{attrs} denotes an atrribute set (that is, a map
from strings to values). An \emph{attrpath} is a dot-separated list of
attribute names.

\begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}

  \parbox[t]{8em}{\emph{attrs}\texttt{.}\emph{attrpath} \\
    $[$ \texttt{or} \emph{expr} $]$}
  & Attribute selection (with default if attribute does not exist). \\

  \emph{attrs} \texttt{?} \emph{attrpath} & Test whether attribute
  exists. \\

  \cmd{++} & List concatenation. \\
  
  \cmd{*}, \cmd{/}, \cmd{-}, \cmd{+} & Arithmetic (including unary
  minus, which has higher precedence than attribute testing). \\
  
  \cmd{+} & String (and path) concatenation. \\

  \emph{attrs} \cmd{//} \emph{attrs} & Update attribute set on the
  left with the entries from the attribute set on the right. \\
  
  \cmd{<}, \cmd{<=}, \cmd{>}, \cmd{>=}, \cmd{==}, \cmd{!=} &
  Comparison. \\

  \cmd{!}, \cmd{\&\&}, \cmd{||}, \cmd{->} & Logical operators,
  including negation and implication. (Negation has higher precendence
  than comparison.) \\
  
\end{tabularx}

\subsection*{Constants}
Specific values show the value of the constant as of today, on my
machine.

\begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}
\cmd{currentSystem} & \cmd{"aarch64-darwin"}. \\
\cmd{currentTime} & 1700936742. Unix time; does not update on repeated
evaluation. \\
\cmd{nixVersion} & \cmd{"2.18.1"}, as returned by `cmd{nix -{}-version}'. \\
\cmd{langVersion} & 6. \\
\cmd{builtins} & \cmd{\{\ ...\ \}}. This very list! \\
\cmd{storeDir} & \cmd{"/nix/store"}. \\
\cmd{nixPath} & \cmd{[\ ...\ ]} List of paths to search when a path is
written in the form \cmd{<\emph{path}>}.  \\
\cmd{derivation} & \cmd{«lambda @ /builtin/derivation.nix:5:1»} No
idea! \\
\cmd{true}, \cmd{false} & Boolean values. \\
\cmd{null} & The value \cmd{null}. \\
\end{tabularx}

\subsection*{Derivations}

% \begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}
  \cmd{addDrvOutputDependencies} ?

    Create a copy of the given string where a single consant string context element is turned into a "derivation deep" string context element.

    The store path that is the constant string context element should point to a valid derivation, and end in .drv.

    The original string context element must not be empty or have multiple elements, and it must not have any other type of element other than a constant or derivation deep element. The latter is supported so this function is idempotent.

    This is the opposite of builtins.unsafeDiscardOutputDependency.
  
\cmd{addErrorContext} ?
\cmd{appendContext} ?

% \end{tabularx}

\subsection*{Arithmetic and logical}
\begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}
  \cmd{add} &  $\num \to \num \to \num$. \\
  \cmd{bitAnd} & $\num \to \num \to \num$. \\
  \cmd{bitOr} & $\num \to \num \to \num$. \\
  \cmd{bitXor} & $\num \to \num \to \num$. \\
  
\end{tabularx}

\subsection*{Lists}
\begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}
\cmd{all} & $(\alpha \to \bln) \to \lst \to \bln$. \\
\cmd{any} & $(\alpha \to \bln) \to \lst \to \bln$. \\ 
\end{tabularx}

\subsection*{Attribute sets}
\begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}
\cmd{attrNames} & $\ats \to \lst$. Names, alphabetically
sorted. \\
\cmd{attrValues} & $\ats \to \lst$. Values, in the same order as returned
by\cmd{attrNames}. \\
\cmd{catAttrs} & $\str \to \lst[\ats] \to \lst$. Return the values of a
named attribute from a list of attribute sets.

\end{tabularx}

\subsection*{Paths and strings}
\begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}
\cmd{baseNameOf} & $\str\to\str$. Everything following the last \cmd{/}.

\end{tabularx}

\subsection*{Other}
\begin{tabularx}{\columnwidth}{@{}l>{\raggedright\arraybackslash}X@{}}
\cmd{abort} & $\str \to \bot $. Abort and print message. \\
\cmd{break} & $\str \to \bot $. In debug mode, enter REPL.\@ Otherwise print string.

\end{tabularx}


\cmd{ceil}:
\cmd{compareVersions}:
\cmd{concatLists}:
\cmd{concatMap}:
\cmd{concatStringsSep}:
\cmd{deepSeq}:
\cmd{derivationStrict}:
\cmd{dirOf}:
\cmd{div}:
\cmd{elem}:
\cmd{elemAt}:; false = false
\cmd{fetchGit}:
\cmd{fetchMercurial}:
\cmd{fetchTarball}:
\cmd{fetchTree}:
\cmd{fetchurl}:
\cmd{filter}:
\cmd{filterSource}:
\cmd{findFile}:
\cmd{flakeRefToString}:
\cmd{floor}:
\cmd{foldl'}:
\cmd{fromJSON}:
\cmd{fromTOML}:
\cmd{functionArgs}:
\cmd{genList}:
\cmd{genericClosure}:
\cmd{getAttr}:
\cmd{getContext}:
\cmd{getEnv}:
\cmd{getFlake}:
\cmd{groupBy}:
\cmd{hasAttr}:
\cmd{hasContext}:
\cmd{hashFile}:
\cmd{hashString}:
\cmd{head}:
\cmd{import}:
\cmd{intersectAttrs}:
\cmd{isAttrs}:
\cmd{isBool}:
\cmd{isFloat}:
\cmd{isFunction}:
\cmd{isInt}:
\cmd{isList}:
\cmd{isNull}:
\cmd{isPath}:
\cmd{isString}:
\cmd{length}:
\cmd{lessThan}:
\cmd{listToAttrs}:
\cmd{map}:
\cmd{mapAttrs}:
\cmd{match}:
\cmd{mul}:

\cmd{parseDrvName}:
\cmd{parseFlakeRef}:
\cmd{partition}:
\cmd{path}:
\cmd{pathExists}:
\cmd{placeholder}:
\cmd{readDir}:
\cmd{readFile}:
\cmd{readFileType}:
\cmd{removeAttrs}:
\cmd{replaceStrings}:
\cmd{scopedImport}:
\cmd{seq}:
\cmd{sort}:
\cmd{split}:
\cmd{splitVersion}:
\cmd{storePath}:
\cmd{stringLength}:
\cmd{sub}:
\cmd{substring}:
\cmd{tail}:
\cmd{throw}:
\cmd{toFile}:
\cmd{toJSON}:
\cmd{toPath}:
\cmd{toString}:
\cmd{toXML}:
\cmd{trace}:
\cmd{traceVerbose}:
\cmd{tryEval}:
\cmd{typeOf}:
\cmd{unsafeDiscardOutputDependency}:
\cmd{unsafeDiscardStringContext}:
\cmd{unsafeGetAttrPos}:
\cmd{zipAttrsWith}:

  

\end{multicols*}
\end{document}
